\documentclass{beamer}
\addtobeamertemplate{footline}{\insertframenumber/\inserttotalframenumber}

\usepackage[utf8]{inputenc}
\usepackage{default}
\usepackage{amsfonts,amsmath,amssymb,amsthm,amstext,latexsym}
\usepackage{listings}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage{bold-extra}
\usepackage{multirow}
\usepackage{verbatim}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,shapes}
\usetikzlibrary{patterns,snakes}
\definecolor{mygray}{gray}{0.9}
\begin{document}

\begin{frame}

  \begin{center}
    \Huge
    Approximate computing
  \end{center}
  Reduce the execution time of an application by giving inexact results.
  \pause
  \begin{itemize}
    \item Precision of a floating-point value
    \item No exact result exists (search query...)
    \item ...
  \end{itemize}
  \pause
  \begin{itemize}
   \item Skip steps in loops
   \item Branching to avoid useless computations
   \item Faulty hardware (fast adders...)
   \item ...
  \end{itemize}

\end{frame}

\begin{frame}{Multi-grid}
 Solve $\beta u''(x)+\alpha u(x)=f(x)$ in $u$, on $[0;1]$ and $u(0)=u(1)=0$.\\ \vspace{0.3cm}
 Interpolate function on a grid of step $h=\frac{1}{N}$, $x_i = \frac{i}{N}$, $i=0..N$.\\
 $u''(x_i) \approx \frac{u(x_{i-1})-2u(x_i)+u(x_{i+1})}{h^2} \Rightarrow Au = f$, $A \in \mathcal{M}_n(\mathbb{R}^{N-1xN-1})$.\\ \vspace{0.3cm}
 
 Then relax, $u_{i+1} = M u_{i} + N f$. What is $u_{0}$? How fast does it converge to $u$?
\end{frame}

\begin{frame}{Multi-grid}
 The idea is to use different values of $h$, different grids: $h,2h,\dots,H$.\\
 $u^{2h}$ can be a good initial guess for $u^h_0$.\\
 It also improves the convergence speed.\vspace{0.5cm}
 
 Two measures have to be taken into account, the error $e$ and the residual $r$: $u = u_i + e_i \Rightarrow Ae_i = f-Au_i = r_i$.
 
\end{frame}

\begin{frame}{Grids}

  \begin{tikzpicture}
      \draw[-] (0,-1) -- (0,5) ;
      \draw[-] (1,-1) -- (1,5) ;
      \draw[-] (2,-1) -- (2,5) ;
      \draw[-] (3,-1) -- (3,5) ;
      \draw[-] (4,-1) -- (4,5) ;
      \draw[-] (-1,0) -- (5,0) ;
      \draw[-] (-1,1) -- (5,1) ;
      \draw[-] (-1,2) -- (5,2) ;
      \draw[-] (-1,3) -- (5,3) ;
      \draw[-] (-1,4) -- (5,4) ;
      \foreach \x in {0,1,2,3,4}
    \foreach \y in {0,1,2,3,4}
      {
        \fill (\x,\y) circle (0.1cm);
      }
      \only<1>{
      \foreach \x in {0,1,2,3,4}
    \foreach \y in {0,1,2,3,4}
      {
        \fill[red] (\x,\y) circle (0.09cm);
      }}
      \only<2>{
      \foreach \x in {0,2,4}
    \foreach \y in {0,2,4}
      {
        \fill[red] (\x,\y) circle (0.09cm);
      }
      }
      \only<3>{
      \foreach \x in {0,4}
    \foreach \y in {0,4}
      {
        \fill[red] (\x,\y) circle (0.09cm);
      }
      }
  \end{tikzpicture}
  \hspace{1cm}
  \begin{tikzpicture}
      \draw[-] (0,-1) -- (0,5) ;
    \foreach \y in {0,1,2,3,4}
      {
        \fill (0,\y) circle (0.1cm);
      }
      \only<1>{
    \foreach \y in {0,1,2,3,4}
      {
        \fill[red] (0,\y) circle (0.09cm);
      }}
      \only<2>{
    \foreach \y in {0,2,4}
      {
        \fill[red] (0,\y) circle (0.09cm);
      }
      }
      \only<3>{
    \foreach \y in {0,4}
      {
        \fill[red] (0,\y) circle (0.09cm);
      }
      }
  \end{tikzpicture}

 
\end{frame}


\begin{frame}{Multi-grid}
  V-cycle$(h,H,\alpha_1,\alpha_2)$:\\
  \begin{enumerate}
    \item $s \leftarrow h; u^h\leftarrow0$
   \item Relax $\alpha_1$ times on grid $s$, initial guess $u^s$.
   \item if $s<H$ : $f^{2s} \leftarrow I_{s\rightarrow 2s}(f^s-A^su^s)$,$u^{2s}\leftarrow0$,$s \leftarrow 2s$ and goto 2.
   \item $u^s \leftarrow u^s+I_{2s\rightarrow s} u^{2s}$.
   \item Relax $\alpha_2$ times on grid $s$, initial guess $u^s$
   \item if $s > h$ : $s = s/2$ and goto 4.
  \end{enumerate}

  Two ways of controlling the execution time and precision: limiting the number of steps ($\alpha_1,\alpha_2$), do several V-cycles and stopping when reaching a given precision $\epsilon$ or a maximum number of V-cycles.
  
\end{frame}

\begin{frame}{BoomerAMG and AMG2006}
  
  \begin{itemize}
   \item Execute 3D problems (Laplace on a cube...)
   \item Default parameters: 8x8x8=512 variables
   \item Solved with preconditioned conjudate gradient, using BoomerAMG preconditioner (HYPRE library)
   \pause
   \item Measures done on execution of BoomerAMG algorithm to directly solve $Ax=b$, not as preconditioner!
   \item Different parameters to play with:
    \begin{itemize}
      \item Tolerance ($\epsilon$) for relative residual norm
      \item Max number of cycles
      \item Type of cycle
      \item Number of relaxations at each step
      \item Number of variables
    \end{itemize}
    
  \end{itemize}
 
\end{frame}

\begin{frame}{Types of cycle}
 
 
\end{frame}

\begin{frame}{Cost of a $k$-cycle}
 
 Using a grid with $N$ points for each of the $d$ dimensions, doing $s$ relaxations at each level:
 \begin{itemize}
  \item V-cycle (1-cycle) costs $\leq \frac{2}{1-2^{-d}} sN^d$
  \item W-cycle (2-cycle) costs $\leq \frac{3}{1-2^{1-d}} sN^d$
  \item $k$-cycle costs $\leq \frac{k+1}{1-k2^{-d}} sN^d$
 \end{itemize}
\end{frame}

\begin{frame}{Results - 80x80x80}
 %\includegraphics[width=\linewidth]{AMG2006/test/edit/convergence_1.pdf}
\end{frame}
\begin{frame}{Results - 80x80x80}
% \includegraphics[width=\linewidth]{AMG2006/test/edit/time_convergence.pdf}
\end{frame}
\begin{frame}{Results - 40x40x40}
 %\includegraphics[width=\linewidth]{AMG2006/test/edit/convergence_1_small.pdf}
\end{frame}
\begin{frame}{Results - 40x40x40}
 %\includegraphics[width=\linewidth]{AMG2006/test/edit/time_convergence_small.pdf}
\end{frame}

\begin{frame}{Results}
80x80x80:
\vspace{-0.8cm}
 \begin{table}
  \resizebox{\linewidth}{!}{
     \begin{tabular}{|c||c|c|c|c||c|c|c|c|}
     \hline
       Parameters & V (1) & V (2) & V (3) & V (10) & W (1) & W (2) & W (3) & W (10) \\
     \hline
       Slope	  & 0.123 & 0.207 & 0.304 & 0.799 & 0.248 & 0.443 & 0.591 & 1.758 \\
     \hline
       Offset     & -0.046 & 0.069 & 0.151 & 0.082 & 0.078 & 0.038 & -0.003 & -0.030 \\
     \hline
     \end{tabular}
  }
 \end{table}
\vspace{-0.5cm}
 \begin{table}
     \begin{tabular}{|c|c|c|c|c|c|}
     \hline
       W/V & 1 & 2 & 3 & 10 & Theoretical \\
     \hline
       Value	  & 2.018 & 2.149 & 1.947 & 2.199 & 1.75 \\
     \hline
     \end{tabular}
 \end{table}

40x40x40:
\vspace{-0.8cm}
 \begin{table}
  \resizebox{\linewidth}{!}{
     \begin{tabular}{|c||c|c|c|c||c|c|c|c|}
     \hline
       Parameters & V (1) & V (2) & V (3) & V (10) & W (1) & W (2) & W (3) & W (10) \\
     \hline
       Slope	  & 0.0188 & 0.0298 & 0.0379 & 0.115 & 0.0317 & 0.0547 & 0.0722 & 0.214 \\
     \hline
       Offset     & -0.0340 & -0.0801 & 0.0279 & 0.0382 & 0.00229 & -0.0768 & -0.0397 & -0.0312 \\
     \hline
     \end{tabular}
  }
 \end{table}
\vspace{-0.5cm}
 
 \begin{table}
     \begin{tabular}{|c|c|c|c|c|c|}
     \hline
       W/V & 1 & 2 & 3 & 10 & Theoretical \\
     \hline
       Value	  & 1.685 & 1.836 & 1.906 & 1.852 & 1.75 \\
     \hline
     \end{tabular}
 \end{table}
 
 Ratio between 10x10x10 and 5x5x5 is between 6.540 and 8.561 (average 7.644).
 
 
\end{frame}

\begin{frame}{Execution times in a V-cycle}
 Problem size: 80x80x80. Grid levels: 8.\\ \vspace{0.5cm}
 \resizebox{\linewidth}{!}{
 \begin{tabular}{|c|c|c|c|c|c|c|}
 \hline
 Level & Matrix size & Non-zero & Relax (down) & Relax (up) & Matvec (down) & Matvec (up) \\
 \hline
  0 & 512,000 & 4,042,520 & 20 ms & 20 ms & 15 ms & -\\
 \hline
  1 & 256,000 & 6,475,239 & 20 ms & 25 ms & 12 ms & 4 ms\\
 \hline
  2 & 58893 & 2,000,513 & 8 ms & 8 ms & 3 ms & 2 ms\\
 \hline
  3 & 14285 & 788,509 & 2 ms & 2 ms & 1 ms & 0.7 ms\\
 \hline
  4 & 4238 & 386,333 & 1 ms & 1 ms & 0.5 ms & 0.2 ms\\
 \hline
  5 & 609 & 53,493 & 0 ms & 0 ms & 0 ms & 0 ms\\
 \hline
  6 & 69 & 2,873 & 0 ms & 0 ms & 0 ms & 0 ms\\
 \hline
  7 & 2 & 4 & 0 ms & - & - & 0 ms\\
 \hline
 \end{tabular}
 }\\ \vspace{0.5cm}
Globally, relaxation represents $\approx$66\% of the time of a V-cycle, and matrix-vector products $\approx$25-30\%.
 \end{frame}

\begin{frame}{Ideas}
  Idea: remove or add relaxation steps at given levels $l \in 0,\dots,n-1$.\\
  Observations: removing relaxation steps at finer levels is \textbf{less efficient}. Adding relaxation steps at coarser levels is \textbf{useless}.
  Strategies tested:\\
  \begin{itemize}
   \item \emph{Fast} : no relaxation at level 1.
   \item \emph{Fast2} : 10 relaxations at level $n-3$.
   \item \emph{Fast3} : 2 relaxations at levels $n-3,n-5,\dots,2$.
   \item \emph{Fast4} : no relaxation at level 2.
  \end{itemize}
\end{frame}

% \begin{frame}{Results - 40x40x40}
%  \includegraphics[width=\linewidth]{AMG2006/test/edit/convergence_fast_small.pdf}
% \end{frame}
% \begin{frame}{Results - 40x40x40}
%  \includegraphics[width=\linewidth]{AMG2006/test/edit/time_convergence_fast_small.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80}
%  \includegraphics[width=\linewidth]{AMG2006/test/edit/convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80}
%  \includegraphics[width=\linewidth]{AMG2006/test/edit/time_convergence_fast.pdf}
% \end{frame}

\begin{frame}{Ideas}
  Idea: remove or add relaxation steps at given levels $l \in 0,\dots,n-1$.\\
  Observations: removing relaxation steps at finer levels is \textbf{less efficient}. Adding relaxation steps at coarser levels is \textbf{useless}.
  Strategies tested:\\
  \begin{itemize}
   \item {\color{mygray}\emph{Fast} : no relaxation at level 1.
   \item \emph{Fast2} : 10 relaxations at level $n-3$.
   \item \emph{Fast3} : 2 relaxations at levels $n-3,n-5,\dots,2$.}
   \item \emph{Fast4} : no relaxation at level 2.
   \item \emph{Up} : relaxation only when going up in the cycle.
  \end{itemize}
 \end{frame}
% \begin{frame}{Results - 80x80x80}
%  \includegraphics[width=\linewidth]{AMG2006/test/ASUS/convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80}
%  \includegraphics[width=\linewidth]{AMG2006/test/ASUS/time_convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Laplace27pt}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/27pt/convergence_fast_10.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Laplace27pt}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/27pt/time_convergence_fast_10.pdf}
% \end{frame}
% \begin{frame}{Results - 40x40x40 - Laplace27pt}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/27pt/convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 40x40x40 - Laplace27pt}
% % \includegraphics[width=\linewidth]{AMG2006/test/DELL/27pt/time_convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Laplace}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/laplace/convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Laplace}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/laplace/time_convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Jumps}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/jumps/convergence_fast_10.pdf}
% \end{frame}
% \begin{frame}{Results - 80x80x80 - Jumps}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/jumps/time_convergence_fast_10.pdf}
% \end{frame}
% \begin{frame}{Results - 40x40x40 - Jumps}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/jumps/convergence_fast.pdf}
% \end{frame}
% \begin{frame}{Results - 40x40x40 - Jumps}
%  \includegraphics[width=\linewidth]{AMG2006/test/DELL/jumps/time_convergence_fast.pdf}
% \end{frame}

\begin{frame}{Results on MinoTauro}
 \begin{itemize}
  \item \textbf{Laplace} and 27pt only
  \item Size: 180x180x180 or \textbf{240x240x240}
  \item Topology: \only<1>{3x3x3}\only<3>{4x4x4}\only<2>{6x6x1}
 \end{itemize}
 Similar results as before. Between 1 and 30\% improvement.
%  \begin{center}
%  \only<1>{\includegraphics[width=0.8\linewidth]{AMG2006/test/MT/laplace/time_convergence_27.pdf}}
%  \only<2>{\includegraphics[width=0.8\linewidth]{AMG2006/test/MT/laplace/time_convergence_36.pdf}}
%  \only<3>{\includegraphics[width=0.8\linewidth]{AMG2006/test/MT/laplace/time_convergence_64.pdf}}
%  \end{center}
\end{frame}

\begin{frame}{Relaxation function analysis}
  Let's have a look at the \textbf{variables in the \textsc{Relax}() function}:
  Only a few temporary variables, most of the variables used are the data of the input matrix.
  \begin{itemize}
    \item 2 arrays used to receive/send data
    \item 1 array used as temporary storage
    \item 2 arrays for the gaussian elimination (direct solve at last level)
    \item \textbf{3 temporary variables used as intermediate value}
    \item 5 parameters
   \end{itemize}
   MPFR version: only the single variables were changed to \texttt{mpfr\_t} type.\\
   Float version: all these aforementioned variables and arrays are changed to \texttt{float} and \texttt{float*}.
\end{frame}

\begin{frame}{Impact on execution time}
 
 The float version is longer than the original algorithm when sequential:\\
 \begin{itemize}
  \item 0.275s / 0.157s (10x10x10, 1 iteration, 1x1x1) $\rightarrow 1.75x$
  \item 2.42s / 1.36s (10x10x10, 10 iterations, 1x1x1) $\rightarrow 1.77x$
  \item 1.54s / 0.955s (10x10x10, 10 iterations, 2x1x1) $\rightarrow 1.61x$
  \item 12.25s / 7.15s (20x20x20, 10 iterations, 2x1x1) $\rightarrow 1.71x$
  \item 0.867s / 0.451s (5x5x5, 30 iterations, 1x1x1) $\rightarrow 1.92x$
  \item 4.96s / 5.00s (20x20x20, 10 iterations, \textbf{2x2x2})  $\rightarrow 0.992x$
  \item 5.29s / 5.32s (30x30x30, 10 iterations, \textbf{3x3x3})  $\rightarrow 0.994x$
  \item 0.590s / 0.606s (10x10x10, 10 iterations, \textbf{2x2x2})  $\rightarrow 0.974x$
  \item 1.020s / 1.143s (20x20x20, 10 iterations, \textbf{4x4x4})  $\rightarrow 0.89x$
 \end{itemize}
\end{frame}

\begin{frame}{Impact on execution time}
 The MPFR version adds a very big overhead compared to the original algorithm: about 50 times longer.
 \begin{tabular}{|c|c|c|c|c|}
  \hline
  \#iterations $\backslash$ \#bits & 8 & 16 & 32 & 64 \\
  \hline
  5 & 116.1 & 113.1 & 117.6 & 114.3\\
  \hline
  10 & 235.5 & 240.6 & 234.1 & 232.2\\
  \hline
  15 & 358.6 & 376.3 & 359.3 & 346.2\\
  \hline
  20 & - & 457.1 & 492.8 & 471.6 \\
  \hline
  25 & - & 587.5 & 616.6 & 614.7 \\
  \hline
  30 & - & 688.0 & 744.3 & 704.8 \\
  \hline
  35 & - & - & 904.9 & 836.9\\
  \hline
  40 & - & - & 976.2 & 950.0 \\
  \hline
  45 & - & - & - & 1012.9\\
  \hline
  50 & - & - & - & 1114.9\\
  \hline
 \end{tabular}

\end{frame}

\begin{frame}{Impact on accuracy}
  %\includegraphics[width=\linewidth]{AMG2006/test/MPFR/bits_convergence.pdf}
\end{frame}

\begin{frame}[fragile]{Impact on accuracy}
  $\Rightarrow$ \texttt{res}, \texttt{res0} and \texttt{res2} variables define the accuracy of the relaxation step and the accuracy of the whole algorithm.
  %\resizebox{0.8\linewidth}{!}{\lstinputlisting[language=C, firstline=1832, lastline=1848]{AMG2006/parcsr_ls/par_relax.c}}
\end{frame}

\begin{frame}{Algorithm with adaptive precision}

  $t$ a threshold, $\textsc{Update}(b)$ a function which returns an integer greater than $b$.
  
  \begin{enumerate}
   \only<1>{\item $b \leftarrow 64$.}
   \only<2>{\item $b \leftarrow {\color{red} 16}$.}
   \item \textbf{While} \emph{nb\_iters $<$ max\_iter \textbf{and} rel\_res\_norm $>$ tolerance}
        \begin{enumerate}
	  \item Do a cycle at precision $b$.
	  \item Compute new\_rel\_res\_norm.
	  \only<2>{\item {\color{red} \textbf{If} \emph{new\_rel\_res\_norm $>$ $t \times$rel\_res\_norm} \textbf{Then} $b \leftarrow \textsc{Update}(b)$.}}
	  \item rel\_res\_norm $\leftarrow$ new\_rel\_res\_norm.
	  \item nb\_iters $\leftarrow$ nb\_iters$+1$.
	  \end{enumerate}
  \end{enumerate}
 
\end{frame}

\begin{frame}{Accuracy study}
%  \only<1>{\vspace{0.13cm}\includegraphics[width=\linewidth]{AMG2006/test/PREC_INCR_0.8/laplace/convergence_27_original.pdf}}
%  \only<2>{\vspace{0.13cm}\includegraphics[width=\linewidth]{AMG2006/test/PREC_INCR_0.8/laplace/convergence_27_16.pdf}}
%  \only<3>{\includegraphics[width=\linewidth]{AMG2006/test/PREC_INCR_0.8/laplace/convergence_27_32.pdf}}
%  \only<4>{\includegraphics[width=\linewidth]{AMG2006/test/PREC_INCR_0.8/laplace/convergence_27.pdf}}
\end{frame}

\begin{frame}{Which set of precisions should we choose?}
  \textbf{Main result}: if something (time, energy consumption, \dots) evolves linearly with the number of bits $b$, then, for a given number of precisions $n$, we can minimize it overall by choosing \textbf{\textit{equally spaced precisions}} $(b_2 = 2b_1, b_3 = 3b_1, \dots)$.
\end{frame}

\begin{frame}{Proof}
 From previous observations we can deduce that, for a given precision $b$, the number of cycles needed to reach the threshold $t$ depends linearly on $b$: $\textsc{MaxIter}(b) \approx  kb $ with $k$ a constant.
 \vspace{0.5cm}
 \pause
 
 Assume: we have a set of $b_1,\dots,b_n$ precisions (such that $b_{i+1} = \textsc{Update}(b_i)$). If $T(b)$ denotes the execution time of a cycle at precision $b$, then the total time spent computing at precision $b_i$ is
 \[ (\textsc{MaxIter}(b_{i}) - \textsc{MaxIter}(b_{i-1})) \times T(b_i) \]
\end{frame}

\begin{frame}{Proof}
  Overall:
  \[ \resizebox{\textwidth}{!}{ $ T_{total} = \textsc{MaxIter}(b_1)T(b_1) + \sum\limits_{i=1}^{n-1} (\textsc{MaxIter}(b_{i+1})-\textsc{MaxIter}(b_i))T(b_{i+1}). $ } \]

 Assume: $T(b) = \alpha b+c$ ($\alpha$ and $c$ two constants).
   \begin{equation}
    T_{total}  = k\alpha\left(b_n^2 + \sum\limits_{i=1}^{n-1} (b_i^2 - b_i b_{i+1})\right) + kb_{n}c.
   \end{equation}
   \begin{equation}
    T_{total}  = k\alpha b_n^2\left(1 + \sum\limits_{i=1}^{n-1} (x_i^2 - x_i x_{i+1})\right) + kb_{n}c,\quad x_i = \frac{b_i}{b_n}.
   \end{equation}
\end{frame}

\begin{frame}{Proof}
  The goal is to minimize the following function: $f(x_1,\dots,x_n) = \sum\limits_{i=1}^n x_i^2 - \sum\limits_{i=1}^{n-1} x_ix_{i+1}$\pause, with $x_n \neq 0$.\pause
  
\vspace{0.7cm}
We need to solve the following system:
 \resizebox{\textwidth}{!}{
   $\left\{
   \begin{tabular}{rcl cccccccccc cl}
    $\frac{\partial f(x_1,\dots,x_n)}{\partial x_1}$ & = & $2x_1$ & $-$ & $x_2$  &     &       & & 	 &&     &     &       & = & 0 \\
    $\frac{\partial f(x_1,\dots,x_n)}{\partial x_2}$ & = & $-x_1$ & $+$ & $2x_2$ & $-$ & $x_3$ & & 	 &&     &     &       & = & 0 \\
    & \vdots &&&&&&&&&&&&&\\
    $\frac{\partial f(x_1,\dots,x_{n})}{\partial x_{n-1}}$ & = &        &     &        &     &       & & $-x_{n-2}$ & $+$ & $2x_{n-1}$ & $-$ & $x_n$ & = & 0 \\
    $x_n$ & = & 1 &&&&&&&&&&&&\\
   \end{tabular} \right.$
  }
\end{frame}

\begin{frame}{Proof}
 In a matrix form this is solving $Ax=b$ where:\[ A = \begin{bmatrix}
    2       & -1 &  &  &  \\
    -1       & 2 & -1 &  &  \\
    & \ddots & \ddots & \ddots & \\
    & & -1 & 2 & -1 \\
           &  &  & -1 & 2
\end{bmatrix} \textup{ and } b = \begin{bmatrix} 0 \\ \vdots \\ 0 \\ 1 \end{bmatrix} \]
\pause
This system has a unique solution ($\Delta_n = 1+n$) which is $\begin{bmatrix} \frac{1}{n} & \dots & \frac{n-1}{n} \end{bmatrix}$.

\vspace{0.5cm}
To conclude, if we want to reach the original accuracy (using 64 bits of precision) with 4 different precisions, it is best to use: 16,32,48 and 64.
\end{frame}

\begin{frame}{Number of precisions}
\begin{center}
 \begin{tikzpicture}
      \draw[->] (0,0) -- (5,0) node[right] {$\frac{\textsc{MaxIter}(b)}{k}$};
      \draw[->] (0,0) -- (0,5) node[above] {$t$};
      \draw[-] (4,0.2) -- (4,-0.2) node[below] {64};
      \draw[red,fill=red!30] (0,0) rectangle (4,4);
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\x,blue] plot ({\x},{\x*\x});
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\y,red]  plot ({\y*\y},{\y});
      \draw[domain=0:5,smooth,variable=\x,black] plot ({\x},{\x}) node[right] {$y=\alpha x$};
    \end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}{Number of precisions}
\begin{center}
 \begin{tikzpicture}
      \draw[->] (0,0) -- (5,0) node[right] {$\frac{\textsc{MaxIter}(b)}{k}$};
      \draw[->] (0,0) -- (0,5) node[above] {$t$};
      \draw[-] (1,0.2) -- (1,-0.2) node[below] {16};
      \draw[-] (2,0.2) -- (2,-0.2) node[below] {32};
      \draw[-] (3,0.2) -- (3,-0.2) node[below] {48};
      \draw[-] (4,0.2) -- (4,-0.2) node[below] {64};
      \draw[red,fill=red!30] (0,0) rectangle (1,1);
      \draw[red,fill=red!30] (1,0) rectangle (2,2);
      \draw[red,fill=red!30] (2,0) rectangle (3,3);
      \draw[red,fill=red!30] (3,0) rectangle (4,4);
      \fill[green!30] (0,1) rectangle (1,4);
      \fill[green!30] (1,2) rectangle (2,4);
      \fill[green!30] (2,3) rectangle (3,4);
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\x,blue] plot ({\x},{\x*\x});
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\y,red]  plot ({\y*\y},{\y});
      \draw[domain=0:5,smooth,variable=\x,black] plot ({\x},{\x}) node[right] {$y=\alpha x$};
    \end{tikzpicture}

\end{center}
\end{frame}

\begin{frame}{Number of precisions}
\begin{center}
 \begin{tikzpicture}
      \draw[->] (0,0) -- (5,0) node[right] {$\frac{\textsc{MaxIter}(b)}{k}$};
      \draw[->] (0,0) -- (0,5) node[above] {$t$};
      {\small \draw[-] (1,0.2) -- (1,-0.2) node[below] {16};
      \draw[-] (2,0.2) -- (2,-0.2) node[below] {32};
      \draw[-] (3,0.2) -- (3,-0.2) node[below] {48};
      \draw[-] (4,0.2) -- (4,-0.2) node[below] {64};
      \draw[-] (0.5,0.2) -- (0.5,-0.2) node[below] {8};
      \draw[-] (1.5,0.2) -- (1.5,-0.2) node[below] {24};
      \draw[-] (2.5,0.2) -- (2.5,-0.2) node[below] {40};
      \draw[-] (3.5,0.2) -- (3.5,-0.2) node[below] {56};}
      \draw[red,fill=red!30] (0,0) rectangle (0.5,0.5);
      \draw[red,fill=red!30] (0.5,0) rectangle (1,1);
      \draw[red,fill=red!30] (1,0) rectangle (1.5,1.5);
      \draw[red,fill=red!30] (1.5,0) rectangle (2,2);
      \draw[red,fill=red!30] (2,0) rectangle (2.5,2.5);
      \draw[red,fill=red!30] (2.5,0) rectangle (3,3);
      \draw[red,fill=red!30] (3,0) rectangle (3.5,3.5);
      \draw[red,fill=red!30] (3.5,0) rectangle (4,4);
      \fill[green!30] (0,1) rectangle (1,4);
      \fill[green!30] (1,2) rectangle (2,4);
      \fill[green!30] (2,3) rectangle (3,4);
      \fill[blue!30] (0,0.5) rectangle (0.5,1);
      \fill[blue!30] (1,1.5) rectangle (1.5,2);
      \fill[blue!30] (2,2.5) rectangle (2.5,3);
      \fill[blue!30] (3,3.5) rectangle (3.5,4);
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\x,blue] plot ({\x},{\x*\x});
      %\draw[scale=0.5,domain=-3:3,smooth,variable=\y,red]  plot ({\y*\y},{\y});
      \draw[domain=0:5,smooth,variable=\x,black] plot ({\x},{\x}) node[right] {$y=\alpha x$};
    \end{tikzpicture}
 \end{center}

\end{frame}

\begin{frame}{Simulation}
  \begin{itemize}
   \item Lots of problems with gem5. Running a simple program is OK but it still does not work with MPI.
   \item Problem of conversion between gem5 output and McPAT input (lots of parameters, all scripts existing are too old).
   \item Sniper: McPAT integrated but some test examples do not work. Not tested with MPI yet.
  \end{itemize}
\end{frame}

\begin{frame}{More executions times}

  \begin{table}
  \begin{center}
   \begin{tabular}{|l|c|c|c|c|}
   \hline
    \multirow{2}{*}{Experiment} & \multicolumn{2}{c|}{Single-Precision} & \multicolumn{2}{c|}{Double-precision} \\
    \cline{2-5}
    & Solve (s) & Cycle (ms) & Solve (s) & Cycle (ms) \\
    \hline
    1x1x1 & 2.1853 & 70-80 & 2.6874 & 90 \\
    \hline
    2x1x1 & 1.3912 & 40-50 & 1.6476 & 50-60\\
    \hline
    2x2x1 & 0.8544 & 30-40 & 0.9943 & 40-50 \\
    \hline
    2x2x2 & 0.5393 & 10-20 & 0.6935 & 10-20 \\
    \hline
    4x2x2 & 0.3255 & 0-10 & 0.3802 & 10 \\
    \hline
    4x4x2 & 0.2542 & 0-10 & 0.2815 & 0-10 \\
    \hline
    4x4x4 & 0.3171 & 0-10 & 0.362 & 0-10 \\
    \hline
   \end{tabular}
   \end{center}
   \caption{Average execution times of AMG solver (50 iterations,64x64x64 matrix) using either single or double precision (default iterative method).}
   \label{table.time_measure1}
 \end{table}
\end{frame}

\begin{frame}{More executions times}
  \begin{table}
 \begin{center}
   \begin{tabular}{|l|c|c|c|c|}
   \hline
    \multirow{2}{*}{Experiment} & \multicolumn{2}{c|}{Single-Precision} & \multicolumn{2}{c|}{Double-precision} \\
    \cline{2-5}
    & Solve (s) & Cycle (ms) & Solve (s) & Cycle (ms) \\
    \hline
    1x1x1 & 1.3731 & 40-50 & 1.6986 & 50-60\\
    \hline
    2x1x1 & 0.9028 & 30 & 1.1481 & 40-60\\
    \hline
    2x2x1 & 0.593 & 20 & 0.7015 & 30-40 \\
    \hline
    2x2x2 & 0.3762 & 10 & 0.5316 & 10-20 \\
    \hline
    4x2x2 & 0.2447 & 0-10 & 0.2681 & 0-10 \\
    \hline
    4x4x2 & 0.2032 & 0-10 & 0.2362 & 0-10 \\
    \hline
    4x4x4 & 0.3086 & 0-10 & 0.3477 & 0-10 \\
    \hline
   \end{tabular}
 \end{center}
   \caption{Average execution times of AMG solver (50 iterations,64x64x64 matrix) using either single or double precision (Jacobi method).}
   \label{table.time_measure1}
 \end{table}
\end{frame}

\begin{frame}{Model}
  We look for $a,C,\beta$ and especially $\alpha$ values such that:\\
  \[ \frac{a}{n^\beta}b^\alpha + C. \]
  
  Using Python \textit{lmfit} package we find:
  
  \only<2-3>{Jacobi:\\
  \texttt{$a$:       1.35078684 +/- 0.053680 (3.97\%) (init= 1)\\
    $\alpha$:   0.32214016 +/- 0.038082 (11.82\%) (init= 1)\\
    $\beta$:    0.62281608 +/- 0.045742 (7.34\%) (init= 1)\\
    $C$:       0.02152401 +/- 0.048966 (227.50\%) (init= 0)\\
  }}
  \only<1>{Default:\\
  \texttt{$a$:       2.17186895 +/- 0.052564 (2.42\%) (init= 1) \\                                                                                                                                      
    $\alpha$:   0.29469879 +/- 0.031849 (10.81\%) (init= 1) \\                                                                                                                                      
    $\beta$:    0.71611502 +/- 0.034215 (4.78\%) (init= 1)  \\
    $C$:       0.03042093 +/- 0.046562 (153.06\%) (init= 0) \\
    }}
    \uncover<3>{
   \[ \alpha \approx \frac{1}{3} \quad\quad T(b) \sim \sqrt[3]{b} \]}
\end{frame}

\begin{frame}{Evaluation}

%  \includegraphics[width=\textwidth]{figs/eval_3.pdf}
\end{frame}
\begin{frame}{Evaluation}

%  \includegraphics[width=\textwidth]{figs/eval_5.pdf}
\end{frame}
\begin{frame}{Evaluation}

 % \includegraphics[width=\textwidth]{figs/eval_7.pdf}
\end{frame}
\begin{frame}{Evaluation}

%  \includegraphics[width=\textwidth]{figs/eval_10.pdf}
\end{frame}
\begin{frame}{Evaluation}

 % \includegraphics[width=\textwidth]{figs/eval_15.pdf}
\end{frame}

\begin{frame}{Final results}
  Depending on the accuracy we want to reach, the efficiency of our algorithm changes.\\
  \vspace{0.5cm}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{|c|c|c|c|}
    \hline
    Tolerance & Time units (Model) & Time units (Baseline) & Improvement \\
    \hline
    \hline
    1e-3 & 3.1362 & 5 & 37.3\% \\
    \hline
    1e-5 & 7.74365 & 11 & 29.6\% \\
    \hline
    1e-7 & 12.8153 & 17 & 24.6\% \\
    \hline
    1e-10 & 21.8153 & 26 & 16.1\% \\
    \hline
    1e-15 & 38.8153 & 43 & 9.7\% \\
    \hline
  \end{tabular}}

\end{frame}


\end{document}
